trigger:
  - main
  - feature/*
  - fix/*

pr:
  - main

pool:
  name: adotest2

variables:
  pythonVersion: '3.12'
  artifactName: 'test-results'

stages:
  - stage: Build_and_Test
    displayName: 'Build and Test'
    jobs:
      - job: BuildAndTest
        displayName: 'Build, Test, and Security Scan'
        steps:
          # Setup Python
          #- task: UsePythonVersion@0
          #  inputs:
          #    versionSpec: '$(pythonVersion)'
          #  displayName: 'Use Python $(pythonVersion)'

          # Install dependencies
          - script: |
              python -m pip install --upgrade pip
              pip install -r requirements.txt
            displayName: 'Install dependencies'

          # Run pytest with coverage
          - script: |
              mkdir -p $(Build.ArtifactStagingDirectory)/junit
              PYTHONPATH=$(Build.SourcesDirectory) pytest tests/ \
                --junitxml=$(Build.ArtifactStagingDirectory)/junit/test-results.xml \
                --cov=src --cov-report=xml --cov-report=html --cov-report=term \
                -v
            displayName: 'Run pytest with coverage'
            continueOnError: true

          # Publish pytest results
          - task: PublishTestResults@2
            inputs:
              testResultsFormat: 'JUnit'
              testResultsFiles: '$(Build.ArtifactStagingDirectory)/junit/test-results.xml'
              testRunTitle: 'Python Unit Tests'
              publishRunAttachments: true
            displayName: 'Publish test results'
            condition: always()

          # Publish code coverage with Cobertura
          - task: PublishCodeCoverageResults@2
            inputs:
              codeCoverageTool: 'cobertura'
              summaryFileLocation: '$(Build.SourcesDirectory)/coverage.xml'
              reportDirectory: '$(Build.SourcesDirectory)/htmlcov'
              failIfCoverageEmpty: false
            displayName: 'Publish code coverage'
            condition: always()

          # Run Bandit for security vulnerability scanning
          - script: |
              bandit -r src/ -f json -o $(Build.ArtifactStagingDirectory)/bandit-report.json || true
              bandit -r src/ -f html -o $(Build.ArtifactStagingDirectory)/bandit-report.html || true
            displayName: 'Run Bandit security scan'
            continueOnError: true

          # Publish Bandit report as artifact
          - task: PublishBuildArtifacts@1
            inputs:
              PathtoPublish: '$(Build.ArtifactStagingDirectory)'
              ArtifactName: '$(artifactName)-bandit'
            displayName: 'Publish Bandit report'
            condition: always()

          # Install Trivy for dependency scanning
          - script: |
              VERSION=$(curl --silent "https://api.github.com/repos/aquasecurity/trivy/releases/latest" | grep '"tag_name":' | sed -E 's/.*"v([^"]+)".*/\1/')
              TRIVY_URL="https://github.com/aquasecurity/trivy/releases/download/v${VERSION}/trivy_${VERSION}_Linux-64bit.tar.gz"
              mkdir -p /tmp/trivy-download
              cd /tmp/trivy-download
              wget -q "${TRIVY_URL}" -O trivy.tar.gz
              tar -xzf trivy.tar.gz
              sudo mv trivy /usr/local/bin/
              trivy --version
            displayName: 'Install Trivy'
            continueOnError: true

          # Run Trivy for dependency scanning
          - script: |
              mkdir -p $(Build.ArtifactStagingDirectory)/trivy
              trivy fs --format json --output $(Build.ArtifactStagingDirectory)/trivy/scan-report.json . || true
              trivy fs --format sarif --output $(Build.ArtifactStagingDirectory)/trivy/scan-report.sarif . || true
            displayName: 'Run Trivy dependency scan'
            continueOnError: true

          # Copy coverage.xml to staging directory
          - script: |
              cp coverage.xml $(Build.ArtifactStagingDirectory)/coverage.xml 2>/dev/null || true
            displayName: 'Copy coverage files'
            condition: always()

          # Publish all artifacts
          - task: PublishBuildArtifacts@1
            inputs:
              PathtoPublish: '$(Build.ArtifactStagingDirectory)'
              ArtifactName: '$(artifactName)-all'
            displayName: 'Publish all test and scan artifacts'
            condition: always()

  - stage: Report
    displayName: 'Security and Coverage Report'
    dependsOn: Build_and_Test
    condition: always()
    jobs:
      - job: ReportGeneration
        displayName: 'Generate Reports'
        steps:
          - task: DownloadBuildArtifacts@0
            inputs:
              buildType: 'current'
              downloadType: 'all'
            displayName: 'Download all artifacts'
            condition: always()

          - script: |
              echo "=== Pytest Summary ==="
              if [ -f "$(Pipeline.Workspace)/**/test-results.xml" ]; then
                echo "Test report generated successfully"
              fi
              echo "=== Bandit Summary ==="
              if [ -f "$(Pipeline.Workspace)/**/bandit-report.json" ]; then
                echo "Bandit security scan completed"
              fi
              echo "=== Trivy Summary ==="
              if [ -f "$(Pipeline.Workspace)/**/scan-report.sarif" ]; then
                echo "Trivy dependency scan completed"
              fi
            displayName: 'Generate build report'
            condition: always()

  - stage: Release
    displayName: 'Release and Package'
    dependsOn: Build_and_Test
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    jobs:
      - job: CreateRelease
        displayName: 'Create Release and Generate Changelog'
        steps:
          # Determine version and create git tag using semantic versioning
          - script: |
              # Get latest tag
              LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
              echo "Latest tag: $LATEST_TAG"
              
              # Extract version numbers
              MAJOR=$(echo $LATEST_TAG | cut -d. -f1 | sed 's/v//')
              MINOR=$(echo $LATEST_TAG | cut -d. -f2)
              PATCH=$(echo $LATEST_TAG | cut -d. -f3)
              
              # Increment patch version
              NEW_PATCH=$((PATCH + 1))
              NEW_VERSION="v${MAJOR}.${MINOR}.${NEW_PATCH}"
              
              echo "##vso[task.setvariable variable=releaseVersion]$NEW_VERSION"
              echo "New release version: $NEW_VERSION"
            displayName: 'Determine semantic version'

          # Generate changelog from git commits
          - script: |
              RELEASE_VERSION=$(releaseVersion)
              CHANGELOG_FILE="CHANGELOG.md"
              
              # Create header for new release
              {
                echo "# Changelog"
                echo ""
                echo "## [$RELEASE_VERSION] - $(date +%Y-%m-%d)"
                echo ""
                echo "### Added"
                git log --oneline --pretty=format:"- %s" HEAD~10..HEAD 2>/dev/null | head -20 || echo "- Initial release"
                echo ""
                echo "### Fixed"
                echo "- Bug fixes and improvements from previous releases"
                echo ""
                echo "### Security"
                echo "- Security scans and vulnerability assessments performed"
                echo ""
                if [ -f "$CHANGELOG_FILE" ]; then
                  tail -n +2 "$CHANGELOG_FILE"
                fi
              } > CHANGELOG.md.tmp && mv CHANGELOG.md.tmp CHANGELOG.md
              
              cat CHANGELOG.md
            displayName: 'Generate changelog'

          # Create git tag and commit
          - script: |
              RELEASE_VERSION=$(releaseVersion)
              
              # Configure git credentials
              git config user.email "release-bot@azuredevops.local"
              git config user.name "Release Bot"
              
              # Add changelog to git
              git add CHANGELOG.md
              git commit -m "chore: Release $RELEASE_VERSION" || true
              
              # Create and push tag
              git tag "$RELEASE_VERSION" -m "Release $RELEASE_VERSION"
              git push origin "$RELEASE_VERSION" --force 2>/dev/null || echo "Tag push skipped in non-main scenarios"
              
              echo "Git tag created: $RELEASE_VERSION"
            displayName: 'Create git tag for release'

          # Package application into zip
          - script: |
              RELEASE_VERSION=$(releaseVersion)
              PACKAGE_NAME="testado26-${RELEASE_VERSION}"
              PUBLISH_DIR="$(Build.ArtifactStagingDirectory)/release"
              
              mkdir -p "$PUBLISH_DIR"
              
              # Create zip package excluding unnecessary files
              cd $(Build.SourcesDirectory)
              zip -r "$PUBLISH_DIR/${PACKAGE_NAME}.zip" \
                src/ tests/ requirements.txt README.md CHANGELOG.md \
                -x "*.pyc" "__pycache__/*" ".git/*" ".gitignore" \
                "*.egg-info/*" ".pytest_cache/*" "htmlcov/*"
              
              echo "Package created: $PUBLISH_DIR/${PACKAGE_NAME}.zip"
              ls -lh "$PUBLISH_DIR/${PACKAGE_NAME}.zip"
            displayName: 'Package application as zip'

          # Publish release artifacts
          - task: PublishBuildArtifacts@1
            inputs:
              PathtoPublish: '$(Build.ArtifactStagingDirectory)/release'
              ArtifactName: 'release-package'
            displayName: 'Publish release package'
            condition: always()

          # Publish changelog
          - task: PublishBuildArtifacts@1
            inputs:
              PathtoPublish: '$(Build.SourcesDirectory)'
              ArtifactName: 'release-notes'
              PathtoPublishIncludesPattern: 'CHANGELOG.md'
            displayName: 'Publish changelog'
            condition: always()

          # Create release summary
          - script: |
              RELEASE_VERSION=$(releaseVersion)
              echo "##[section]Release Summary"
              echo "Version: $RELEASE_VERSION"
              echo "Build ID: $(Build.BuildId)"
              echo "Build Number: $(Build.BuildNumber)"
              echo "Source Branch: $(Build.SourceBranch)"
              echo ""
              echo "Artifacts:"
              echo "  - Release Package: testado26-${RELEASE_VERSION}.zip"
              echo "  - Changelog: CHANGELOG.md"
            displayName: 'Display release summary'
